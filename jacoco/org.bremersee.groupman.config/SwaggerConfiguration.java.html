<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SwaggerConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">groupman</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.groupman.config</a> &gt; <span class="el_source">SwaggerConfiguration.java</span></div><h1>SwaggerConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.groupman.config;

import com.fasterxml.classmate.ResolvedType;
import com.fasterxml.classmate.TypeResolver;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.ResponseEntity;
import org.springframework.util.StringUtils;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.schema.AlternateTypeRule;
import springfox.documentation.schema.AlternateTypeRules;
import springfox.documentation.schema.WildcardType;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2WebFlux;

/**
 * The swagger configuration.
 *
 * @author Christian Bremer
 */
@ConditionalOnWebApplication
@Configuration
@EnableConfigurationProperties(SwaggerProperties.class)
@EnableSwagger2WebFlux
public class SwaggerConfiguration {

  private SwaggerProperties swaggerProperties;

  private TypeResolver resolver;

  /**
   * Instantiates a new swagger configuration.
   *
   * @param swaggerProperties the swagger properties
   * @param resolver          the resolver
   */
<span class="fc" id="L65">  public SwaggerConfiguration(SwaggerProperties swaggerProperties, TypeResolver resolver) {</span>
<span class="fc" id="L66">    this.swaggerProperties = swaggerProperties;</span>
<span class="fc" id="L67">    this.resolver = resolver;</span>
<span class="fc" id="L68">  }</span>

  /**
   * Returns the swagger docket. The swagger definition will be available under {@code
   * http://localhost:8090/v2/api-docs}**.
   *
   * @return the swagger docket
   */
  @Bean
  public Docket api() {
<span class="fc" id="L78">    return new Docket(DocumentationType.SWAGGER_2)</span>
<span class="fc" id="L79">        .select()</span>
<span class="fc" id="L80">        .apis(RequestHandlerSelectors.any())</span>
<span class="fc" id="L81">        .paths(PathSelectors.ant(&quot;/api/**&quot;))</span>
<span class="fc" id="L82">        .build()</span>
<span class="fc" id="L83">        .pathMapping(swaggerProperties.getPathMapping())</span>
<span class="fc" id="L84">        .apiInfo(apiInfo())</span>

<span class="fc" id="L86">        .alternateTypeRules(new RecursiveAlternateTypeRule(resolver,</span>
<span class="fc" id="L87">            Arrays.asList(</span>
<span class="fc" id="L88">                AlternateTypeRules.newRule(</span>
<span class="fc" id="L89">                    resolver.resolve(Mono.class, WildcardType.class),</span>
<span class="fc" id="L90">                    resolver.resolve(WildcardType.class)),</span>
<span class="fc" id="L91">                AlternateTypeRules.newRule(</span>
<span class="fc" id="L92">                    resolver.resolve(ResponseEntity.class, WildcardType.class),</span>
<span class="fc" id="L93">                    resolver.resolve(WildcardType.class))</span>
            )))
<span class="fc" id="L95">        .alternateTypeRules(new RecursiveAlternateTypeRule(resolver,</span>
<span class="fc" id="L96">            Arrays.asList(</span>
<span class="fc" id="L97">                AlternateTypeRules.newRule(</span>
<span class="fc" id="L98">                    resolver.resolve(Flux.class, WildcardType.class),</span>
<span class="fc" id="L99">                    resolver.resolve(List.class, WildcardType.class)),</span>
<span class="fc" id="L100">                AlternateTypeRules.newRule(</span>
<span class="fc" id="L101">                    resolver.resolve(ResponseEntity.class, WildcardType.class),</span>
<span class="fc" id="L102">                    resolver.resolve(WildcardType.class))</span>
            )));

  }

  private ApiInfo apiInfo() {
    final Contact contact;
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">    if (StringUtils.hasText(swaggerProperties.getContactName())</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        || StringUtils.hasText(swaggerProperties.getContactUrl())</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        || StringUtils.hasText(swaggerProperties.getContactEmail())) {</span>
<span class="nc" id="L112">      contact = new Contact(</span>
<span class="nc" id="L113">          swaggerProperties.getContactName(),</span>
<span class="nc" id="L114">          swaggerProperties.getContactUrl(),</span>
<span class="nc" id="L115">          swaggerProperties.getContactEmail());</span>
    } else {
<span class="fc" id="L117">      contact = null;</span>
    }
<span class="fc" id="L119">    return new ApiInfo(</span>
<span class="fc" id="L120">        swaggerProperties.getTitle(),</span>
<span class="fc" id="L121">        swaggerProperties.getDescription(),</span>
<span class="fc" id="L122">        swaggerProperties.getVersion(),</span>
<span class="fc" id="L123">        swaggerProperties.getTermsOfServiceUrl(),</span>
        contact,
<span class="fc" id="L125">        swaggerProperties.getLicense(),</span>
<span class="fc" id="L126">        swaggerProperties.getLicenseUrl(),</span>
<span class="fc" id="L127">        Collections.emptyList());</span>
  }

  /**
   * The type Recursive alternate type rule.
   */
  public static class RecursiveAlternateTypeRule extends AlternateTypeRule {

    private List&lt;AlternateTypeRule&gt; rules;

    /**
     * Instantiates a new Recursive alternate type rule.
     *
     * @param typeResolver the type resolver
     * @param rules        the rules
     */
    public RecursiveAlternateTypeRule(TypeResolver typeResolver, List&lt;AlternateTypeRule&gt; rules) {
      // Unused but cannot be null
<span class="fc" id="L145">      super(typeResolver.resolve(Object.class), typeResolver.resolve(Object.class));</span>
<span class="fc" id="L146">      this.rules = rules;</span>
<span class="fc" id="L147">    }</span>

    @Override
    public ResolvedType alternateFor(ResolvedType type) {
<span class="fc" id="L151">      Stream&lt;ResolvedType&gt; rStream = rules.stream()</span>
<span class="fc" id="L152">          .flatMap(rule -&gt; Stream.of(rule.alternateFor(type)));</span>
<span class="fc" id="L153">      ResolvedType newType = rStream</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">          .filter(alternateType -&gt; alternateType != type).findFirst().orElse(type);</span>

<span class="pc bpc" id="L156" title="1 of 2 branches missed.">      if (appliesTo(newType)) {</span>
        // Recursion happens here
<span class="nc" id="L158">        return alternateFor(newType);</span>
      }

<span class="fc" id="L161">      return newType;</span>
    }

    @Override
    public boolean appliesTo(ResolvedType type) {
<span class="fc" id="L166">      return rules.stream().anyMatch(rule -&gt; rule.appliesTo(type));</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>